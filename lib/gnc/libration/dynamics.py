import numpy
import lib.tools.math_toolbox.ode.solver as solver

from lib.tools.physics_toolbox import energy
from lib.simcore.support.datatypes import Vector
from lib.simcore.support.variables import GLOBALS
from lib.tools.math_toolbox.integration.integrands import CRTBP as Functional


class Orbit(object):
    ''' Dynamics for the L2 Halo Orbit '''
    
    def __init__(self, small_bdy=GLOBALS.DEFAULT['MU'], large_bdy=GLOBALS.DEFAULT['MU']):
        self.mu = small_bdy/(small_bdy + large_bdy)
        self.position = Vector((1.0874,0.0,0.2020), 'L2 Inertial')
        self.velocity = Vector((0.0,-0.2054,0.0), 'L2 Inertial')

        self.L2 = self._lagrange_point()
        return

    def _lagrange_point(self, true_root=0):
        ''' Calculate the L2 libration (langrange) point location '''
        mu_a = self.mu
        mu_b = 1 - mu_a

        # Taylor expansion
        poly_coeffs = [1.0,                                   \
                       2*(mu_a-mu_b),                         \
                       mu_b**2 - 4*mu_a*mu_b + mu_a**2,       \
                       2*mu_a*mu_b*(mu_b-mu_a) - (mu_b+mu_a), \
                       (mu_a*mu_b)**2 + 2*(mu_b**2-mu_a**2),  \
                       -(mu_a**3+mu_b**3)]

        # Obtain the minimum 'largest' on the line formed
        # by the Earth-Moon system. This is the L2 point
        roots = numpy.roots(poly_coeffs)
        for idx in range(len(poly_coeffs)-1):
            if  roots[idx] > mu_b:
                true_root = numpy.absolute(roots[idx])
        return true_root

    def _state_transition_matrix_update(self):
        pass

    def change_initial_conditions(self, position=None, velocity=None):
        ''' Change the initial orbital parameters '''
        self.position = Vector(position, 'L2 Inertial')
        self.velocity = Vector(velocity, 'L2 Inertial')
        return

    def get_barycenter_fixed_solution(self, N=1, **kwargs):
        ''' Compute the orbit trajectory after N orbits '''
        kwargs['mu'] = self.mu
        dimension = GLOBALS.CONSTANTS['STATE_VECTOR_DIM']
        
        current_state = list(self.position.at(0)) + list(self.velocity.at(0))
        current_state = numpy.asarray([current_state])

        halo_solution = numpy.empty((6,0))

        for idx in range(N):
            kwargs['state'] = current_state.T
            [_, vstate] = solver.ode113v(**kwargs)
            
            # Using the current state solution, calculate the
            # state matrix required for the current trajectory
            multibody_state = numpy.identity(dimension)
            multibody_state = numpy.reshape(multibody_state, (dimension**2,1))
            kwargs['state'] = numpy.append(multibody_state, current_state.T, axis=0)
            [t_span, mstate]  = solver.ode113m(**kwargs)

            # State matrix vector representation conversion back to matrix
            A = numpy.reshape(mstate[:36,-1], (dimension,dimension))

            # Obtain the directional vector field
            kwargs['y'] = vstate
            vfield = Functional.vfhandle(**kwargs)

            # Solution to state matrix confined to vector field
            # generated by the corresponding state solution at time t
            dF = numpy.asarray([[A[3,0], A[3,4], vfield[3]], \
                              [A[5,0], A[5,4], vfield[5]], \
                              [A[1,0], A[1,4], vfield[1]]], dtype='float')

            inv_dF = numpy.linalg.inv(dF)
            push_state = numpy.asarray([[vstate[3,-1], vstate[5,-1], vstate[1,-1]]])
            
            # Estimate the initial conditions for the next trajectory
            # given the current directional state space solution
            next_state_estimate = numpy.asarray([[current_state[0,0], current_state[0,4], t_span[-1]]])
            next_state_estimate = next_state_estimate.T - numpy.matmul(inv_dF, push_state.T)            
            next_state = numpy.asarray([[next_state_estimate[0,0], 0, self.position.at(0)[2], 0, next_state_estimate[1,0], 0]])

            # Calculate an initial guess at the orbital period
            # index+1 given small deviations in the orbital path
            timespan = (0, next_state_estimate[2,-1])
            current_state = next_state
        
            # Taking advantage of orbital symmetry by
            # multiplying the given trajectory time by two
            kwargs['state'] = current_state.T
            kwargs['tspan'] = (0, 2*timespan[-1])
            [_, trajectory] = solver.ode113v(**kwargs)
            halo_solution = numpy.append(halo_solution, trajectory, axis=1)

            # Use the estimated half period for
            # next orbit cycle calculation time
            kwargs['tspan'] = (0, timespan[-1])
        return halo_solution
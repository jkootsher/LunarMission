import numpy

import lib.tools.math_toolbox.ode.solver as solver

from lib.gnc.libration.frames import Frames
from lib.tools.physics_toolbox import energy
from lib.tools.math_toolbox.integration.integrands import CRTBP as Functional


class Orbit(object):
    ''' Dynamics for the L2 Halo Orbit '''
    
    def __init__(self, Params=None):
        self.mu = Params.sbdy/(Params.sbdy+Params.lbdy)
        self.Params = Params

        self.L2 = self._lagrange_point()
        self.Frames = Frames()
        return

    def _lagrange_point(self, true_root=0):
        ''' Calculate the L2 libration (langrange) point location '''
        mu_a = self.mu
        mu_b = 1 - mu_a

        # Taylor expansion
        poly_coeffs = [1.0,                                   \
                       2*(mu_a-mu_b),                         \
                       mu_b**2 - 4*mu_a*mu_b + mu_a**2,       \
                       2*mu_a*mu_b*(mu_b-mu_a) - (mu_b+mu_a), \
                       (mu_a*mu_b)**2 + 2*(mu_b**2-mu_a**2),  \
                       -(mu_a**3+mu_b**3)]

        # Obtain the minimum 'largest' on the line formed
        # by the Earth-Moon system. This is the L2 point
        roots = numpy.roots(poly_coeffs)
        for idx in range(len(poly_coeffs)-1):
            if  roots[idx] > mu_b:
                true_root = numpy.absolute(roots[idx])
        return true_root

    def get_barycenter_fixed_solution(self, N=1, **kwargs):
        ''' Compute the orbit trajectory after N orbits '''
        kwargs['mu'] = self.mu
        kwargs['delta'] = self.Params.step
        kwargs['tspan'] = (0, self.Params.period/2)
        
        halo_solution = numpy.empty((6,0))
        current_state = numpy.append(self.Params.position, self.Params.velocity)
        current_state = numpy.reshape(current_state, (1,6))

        # Principal orbit
        kwargs['state'] = current_state.T
        [_, vstate] = solver.ode113v(**kwargs)
        
        # Using the current state solution, calculate the
        # state matrix required for the current trajectory
        multibody_state = numpy.identity(6)
        multibody_state = numpy.reshape(multibody_state, (6**2,1))
        kwargs['state'] = numpy.append(multibody_state, current_state.T, axis=0)
        [t_span, mstate]  = solver.ode113m(**kwargs)

        # State matrix vector representation conversion back to matrix
        A = numpy.reshape(mstate[:36,-1], (6,6))

        # Obtain the directional vector field
        kwargs['y'] = vstate
        vfield = Functional.vfhandle(**kwargs)

        # Solution to state matrix confined to vector field
        # generated by the corresponding state solution at time t
        dF = numpy.asarray([[A[3,0], A[3,4], vfield[3]], \
                            [A[5,0], A[5,4], vfield[5]], \
                            [A[1,0], A[1,4], vfield[1]]], dtype='float')

        inv_dF = numpy.linalg.inv(dF)
        push_state = numpy.asarray([[vstate[3,-1], vstate[5,-1], vstate[1,-1]]])
        
        # Estimate the initial conditions for the next trajectory
        # given the current directional state space solution
        next_state_estimate = numpy.asarray([[current_state[0,0], current_state[0,4], t_span[-1]]])
        next_state_estimate = next_state_estimate.T - numpy.matmul(inv_dF, push_state.T)            
        next_state = numpy.asarray([[next_state_estimate[0,0], 0, self.Params.position[2], 0, next_state_estimate[1,0], 0]])

        # Calculate an initial guess at the orbital period
        # index+1 given small deviations in the orbital path
        timespan = (0, next_state_estimate[2,-1])
        current_state = next_state
    
        # Taking advantage of orbital symmetry by
        # multiplying the given trajectory time by two
        kwargs['state'] = current_state.T
        kwargs['tspan'] = (0, 2*timespan[-1])
        [_, trajectory] = solver.ode113v(**kwargs)
        
        # Save computation time by copying principal orbit
        for idx in range(N):
            halo_solution = numpy.append(halo_solution, trajectory, axis=1)
        return halo_solution